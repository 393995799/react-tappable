!function(o){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=o();else if("function"==typeof define&&define.amd)define([],o);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.Tappable=o()}}(function(){return function o(e,t,s){function n(r,c){if(!t[r]){if(!e[r]){var p="function"==typeof require&&require;if(!c&&p)return p(r,!0);if(i)return i(r,!0);var u=new Error("Cannot find module '"+r+"'");throw u.code="MODULE_NOT_FOUND",u}var h=t[r]={exports:{}};e[r][0].call(h.exports,function(o){var t=e[r][1][o];return n(t?t:o)},h,h.exports,o,e,t,s)}return t[r].exports}for(var i="function"==typeof require&&require,r=0;r<s.length;r++)n(s[r]);return n}({1:[function(o,e){(function(t){function s(o){return o?{pageX:o.pageX,pageY:o.pageY,clientX:o.clientX,clientY:o.clientY}:{}}var n="undefined"!=typeof window?window.React:"undefined"!=typeof t?t.React:null;n.initializeTouchEvents(!0);var i=o("react/lib/Object.assign"),r={propTypes:{moveThreshold:n.PropTypes.number,pressDelay:n.PropTypes.number,pressMoveThreshold:n.PropTypes.number,preventDefault:n.PropTypes.bool,stopPropagation:n.PropTypes.bool,onTap:n.PropTypes.func,onPress:n.PropTypes.func,onTouchStart:n.PropTypes.func,onTouchMove:n.PropTypes.func,onTouchEnd:n.PropTypes.func,onMouseDown:n.PropTypes.func,onMouseUp:n.PropTypes.func,onMouseMove:n.PropTypes.func,onMouseOut:n.PropTypes.func},getDefaultProps:function(){return{moveThreshold:100,pressDelay:1e3,pressMoveThreshold:5}},getInitialState:function(){return{isActive:!1,touchActive:!1}},componentWillUnmount:function(){this.cleanupScrollDetection(),this.cancelPressDetection()},processEvent:function(o){this.props.preventDefault&&o.preventDefault(),this.props.stopPropagation&&o.stopPropagation()},onTouchStart:function(o){this.props.onTouchStart&&this.props.onTouchStart(o)===!1||(this.processEvent(o),window._blockMouseEvents=!0,this._initialTouch=this._lastTouch=s(o.touches[0]),this.initScrollDetection(),this.initPressDetection(this.endTouch),this.setState({isActive:!0}))},initScrollDetection:function(){this._scrollParents=[],this._scrollPos={top:0,left:0};for(var o=this.getDOMNode();o;)(o.scrollHeight>o.offsetHeight||o.scrollWidth>o.offsetWidth)&&(this._scrollParents.push(o),this._scrollPos.top+=o.scrollTop,this._scrollPos.left+=o.scrollLeft),o=o.parentNode},calculateMovement:function(o){return{x:Math.abs(o.clientX-this._initialTouch.clientX),y:Math.abs(o.clientY-this._initialTouch.clientY)}},detectScroll:function(){for(var o={top:0,left:0},e=0;e<this._scrollParents.length;e++)o.top+=this._scrollParents[e].scrollTop,o.left+=this._scrollParents[e].scrollLeft;return!(o.top===this._scrollPos.top&&o.left===this._scrollPos.left)},cleanupScrollDetection:function(){this._scrollParents=void 0,this._scrollPos=void 0},initPressDetection:function(o){this.props.onPress&&(this._pressTimeout=setTimeout(function(){this.props.onPress(),o()}.bind(this),this.props.pressDelay))},cancelPressDetection:function(){clearTimeout(this._pressTimeout)},onTouchMove:function(o){if(this._initialTouch){if(this.processEvent(o),this.detectScroll())return this.endTouch(o);this.props.onTouchMove&&this.props.onTouchMove(o),this._lastTouch=s(o.touches[0]);var e=this.calculateMovement(this._lastTouch);(e.x>this.props.pressMoveThreshold||e.y>this.props.pressMoveThreshold)&&this.cancelPressDetection(),e.x>this.props.moveThreshold||e.y>this.props.moveThreshold?this.state.isActive&&this.setState({isActive:!1}):this.state.isActive||this.setState({isActive:!0})}},onTouchEnd:function(o){if(this._initialTouch){this.processEvent(o);var e=this.calculateMovement(this._lastTouch);e.x<=this.props.moveThreshold&&e.y<=this.props.moveThreshold&&this.props.onTap&&this.props.onTap(o),this.endTouch(o)}},endTouch:function(o){this.cancelPressDetection(),this.props.onTouchEnd&&this.props.onTouchEnd(o),this._initialTouch=null,this._lastTouch=null,this.setState({isActive:!1})},onMouseDown:function(o){return window._blockMouseEvents?void(window._blockMouseEvents=!1):void(this.props.onMouseDown&&this.props.onMouseDown(o)===!1||(this.processEvent(o),this.initPressDetection(this.endMouseEvent),this._mouseDown=!0,this.setState({isActive:!0})))},onMouseMove:function(o){!window._blockMouseEvents&&this._mouseDown&&(this.processEvent(o),this.props.onMouseMove&&this.props.onMouseMove(o))},onMouseUp:function(o){!window._blockMouseEvents&&this._mouseDown&&(this.processEvent(o),this.props.onMouseUp&&this.props.onMouseUp(o),this.props.onTap&&this.props.onTap(o),this.endMouseEvent())},onMouseOut:function(o){!window._blockMouseEvents&&this._mouseDown&&(this.processEvent(o),this.props.onMouseOut&&this.props.onMouseOut(o),this.endMouseEvent())},endMouseEvent:function(){this.cancelPressDetection(),this._mouseDown=!1,this.setState({isActive:!1})},touchStyles:function(){return{WebkitTapHighlightColor:"rgba(0,0,0,0)",WebkitTouchCallout:"none",WebkitUserSelect:"none",KhtmlUserSelect:"none",MozUserSelect:"none",msUserSelect:"none",userSelect:"none",cursor:"pointer"}},handlers:function(){return{onTouchStart:this.onTouchStart,onTouchMove:this.onTouchMove,onTouchEnd:this.onTouchEnd,onMouseDown:this.onMouseDown,onMouseUp:this.onMouseUp,onMouseMove:this.onMouseMove,onMouseOut:this.onMouseOut}}},c=n.createClass({displayName:"Tappable",mixins:[r],propTypes:{component:n.PropTypes.any,className:n.PropTypes.string,classBase:n.PropTypes.string,style:n.PropTypes.object,disabled:n.PropTypes.bool},getDefaultProps:function(){return{component:"span",classBase:"Tappable"}},render:function(){var o=this.props.classBase+(this.state.isActive?"-active":"-inactive");this.props.className&&(o+=" "+this.props.className);var e={};return i(e,this.touchStyles(),this.props.style),n.createElement(this.props.component,{style:e,className:o,disabled:this.props.disabled,onTouchStart:this.onTouchStart,onTouchMove:this.onTouchMove,onTouchEnd:this.onTouchEnd,onMouseDown:this.onMouseDown,onMouseMove:this.onMouseMove,onMouseUp:this.onMouseUp,onMouseOut:this.onMouseOut},this.props.children)}});c.Mixin=r,e.exports=c}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"react/lib/Object.assign":2}],2:[function(o,e){function t(o){if(null==o)throw new TypeError("Object.assign target cannot be null or undefined");for(var e=Object(o),t=Object.prototype.hasOwnProperty,s=1;s<arguments.length;s++){var n=arguments[s];if(null!=n){var i=Object(n);for(var r in i)t.call(i,r)&&(e[r]=i[r])}}return e}e.exports=t},{}]},{},[1])(1)});